# 对象已死

GC 在对堆进行回收前，需要先确定哪些对象已经死去，即不再被使用的对象。

## 1. 引用计数算法（Reference Counting）

在对象中添加一个引用计数器，每当有一个地方引用它，计数器加一；当引用失效时，计数器减一；任何时刻计数器为零的对象，就是不能再被使用的。

缺点是单纯的引用计数很难解决对象之间相互循环引用的问题，需要配合大量额外处理。

## 2. 可达性分析算法（Reachability Analysis）

通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走的路径称为“引用链”（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连，或者用图论的话是从 GC Roots 到这个对象不可达时，证明对象是不可能再被使用的。

在 Java 技术体系里面，固定可作为 GC Roots 的对象包括以下几种：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
- 在方法区中类静态属性引用的对象，譬如 Java 类的引用类型静态变量。
- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
- 在本地方法栈中 JNI（即通常所说的 Native 方法）引用的对象。
- Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象、一些常驻的异常对象（比如 NullPointException、OutOfMemoryError）等、系统类加载器。
- 所有被同步锁（synchronized 关键字）持有的对象。
- 反应 Java 虚拟机内部情况的 JMXBean、JVMIT 中注册的回调、本地代码缓存等。

>可作为 GC Roots 的节点主要在全局性的引用（常量、类静态属性等）与执行上下文（栈帧中的本地变量表等）中。

## 3. 再谈引用

在 JDK1.2 之前：如果 reference 类型的数据中存储的数值代表的是另外一个内存的起始地址，就称该 reference 数据是代表某块内存、某个对象的引用。

在 JDK1.2 之后：将引用分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference），引用强度依次减弱。

- 强引用（Strongly Reference）：指在程序代码中普遍存在的引用赋值，即类似“Object obj = new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用对象。
- 软引用（Soft Reference）：用来描述一些还有用，但非必须的对象。只被软引用关联的对象，在系统将要发生内存溢出异常前，会把这些对象列为回收范围之中进行第二次回收，**如果这次回收还没有足够内存**，才会抛出内存溢出异常。在 JDK1.2 之后提供 SoftReference 类来实现软引用。
- 弱引用（Weak Reference）：用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，**无论当前内存是否足够**，都会回收掉只被弱引用关联的对象。在 JDK1.2 之后提供 WeakReference 类来实现弱引用。
- 虚引用（Phantom Reference）：也称为“幽灵引用”或“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象**设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知**。在 JDK1.2 之后提供 PhantomReference 类来实现虚引用。

## 4. 生存还是死亡

1. 如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。
   > 如果对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机都会视为“没有必要执行”。
2. 如果这个对象需要执行 finalize() 方法，对象将被放置在名为 F-Queue 的队列中，并在稍后由一条虚拟机自动创建、低调度优先级的 Finalizer 线程执行它们的 finalize() 方法。
   > 虚拟机会触发方法运行，但不一定等待它运行结束。避免出现执行缓慢或死循环，导致 F-Queue 永久等待。
3. 收集器会对 F-Queue 中的对象进行第二次小规模的标记，如果对象在 finalize() 方法中重新与引用链建立关联，将会在第二次标记时被移除“即将回收”的集合。

>任何一个对象的 finalize() 方法都只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize() 方法不会被再次

## 5. 回收方法区

方法区的垃圾收集主要回收两部分内容：

- 废弃的常量：已经没有任何其他地方引用这个常量，如果发生回收，垃圾收集器判断确有必要，这个常量将被系统清理。
- 不再使用的类型：需要同时满足三个条件
  - 该类所有的实例都已经被回收
  - 加载该类的类加载器已经被回收
  - 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

>HotSpot 虚拟机提供了-Xnoclassgc 参数控制是否对类型进行回收，还可以使用-verbose:class 以及-XX:+ThaceClassLoading、-XX:+TraceClassUnLoading 查看类加载和卸载信息，其中-verbose:class 和-XX:+TraceClassLoading 可以在 Product 版虚拟机中使用，-XX:+TraceClassUnLoading 参数需要 FastDebug 版的支持。
>
>在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 JSP 以及 OSGI 这类频繁自定义类加载器的场景中，通常都需要 Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。
